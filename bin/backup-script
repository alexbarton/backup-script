#!/bin/bash
#
# backup-script system for cloning systems using rsync
# Copyright (c)2008-2014 Alexander Barton, alex@barton.de
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# Please read the file COPYING, README and AUTHORS for more information.
#

NAME=`basename $0`
PIDFILE="/var/run/$NAME.pid"

DRYRUN=0
VERBOSE=0

export LC_ALL=C

declare -i count_all=0
declare -i count_started=0
declare -i count_ok=0
declare -i count_ok_vanished=0

destinations=""

# Default settings, can be overwritten in backup-script.conf:
conf_d="/etc/backup-script.d"
pre_exec=""
post_exec=""
default_target=""
default_user="root"
default_ssh_args_add=""
default_rsync_args_add=""
default_exclude_args_add=""
default_compress=1
default_ping=1
default_local=0
default_generations=0

Usage() {
	echo "Usage: $NAME [<options>] [<system> [<system> [...]]]"
	echo
	echo "  -p, --progress    Show progress, see rsync(1)."
	echo "  -n, --dry-run     Test run only, don't copy any data."
	echo
	echo "When no <system> is given, all defined systems are used."
	echo
	exit 1
}

CleanUp() {
	if [ -n "$post_exec" ]; then
		echo "Executing \"$post_exec\" ..."
		sh -c $post_exec
		if [ $? -ne 0 ]; then
			echo "Warning: post-exec command failed!"
		fi
		echo
	fi
	rm -f "$PIDFILE"
}

GotSignal() {
	echo
	echo "--> Got break signal, cleaning up & aborting ..."
	echo
	CleanUp
	echo -n "Aborted: "; date
	echo
	exit 9
}

while [ $# -gt 0 ]; do
	case "$1" in
	  "-n"|"--dry-run")
		DRYRUN=1; shift
		;;
	  "-p"|"--progress")
		VERBOSE=1; shift
		;;
	  "-"*)
		Usage
		;;
	  *)
		break
	esac
done

trap GotSignal SIGINT

echo -n "Started: "; date

for conf in "/etc/backup-script.conf" "${conf_d}/backup-script.conf"; do
	if [ -r "$conf" ]; then
		echo "Reading configuration: \"$conf\" ..."
		source "$conf"
	fi
done
echo

if [ $# -ge 1 ]; then
	for s in $@; do
		if [ ! -r "${conf_d}/$s" ]; then
			echo "$NAME: Can' read \"${conf_d}/$s\"!"
			exit 1
		fi
		sys="$sys ${conf_d}/$s"
	done
else
	sys=${conf_d}/*
fi

# check and create PID file
if [ -e "$PIDFILE" ]; then
	echo "Lockfile \"$PIDFILE\" already exists."
	echo "Is an other instance still running?"
	echo
	echo -n "Aborted: "; date
	echo
	exit 3
fi
touch "$PIDFILE" 2>/dev/null
if [ $? -ne 0 ]; then
	echo "Warning: can't create PID file \"$PIDFILE\"!"
	echo
else
	echo "$$" >>"$PIDFILE"
fi

if [ -n "$pre_exec" ]; then
	echo "Executing \"$pre_exec\" ..."
	sh -c $pre_exec
	if [ $? -ne 0 ]; then
		echo "Error: pre-exec command failed!"; echo
		CleanUp
		echo "Aborting backup."; echo
		exit 2
	fi
	sleep 2
	echo
fi

for f in $sys; do
	[ -r "$f" -a -f "$f" ] || continue

	fname=`basename $f`
	case "$fname" in
		"backup-script.conf"|*.sh)
			continue
			;;
	esac

	# Set global defaults
	system="$fname"
	user="$default_user"
	target="$default_target"
	ssh_args_add="$default_ssh_args_add"
	rsync_args_add="$default_rsync_args_add"
	exclude_args_add="$default_exclude_args_add"
	compress="$default_compress"
	ping="$default_ping"
	local="$default_local"
	generations="$default_generations"

	# Read in system configuration file
	source "$f"

	# Validate configuration
	[ "$system" = "localhost" -o "$system" = "127.0.0.1" ] && local=1

	[ "$system" = "$fname" ] \
		&& systxt="\"$system\"" \
		|| systxt="\"$fname\" [\"$system\"]"
	[ "$local" -eq 0 ] \
		&& echo "Working on $systxt ..." \
		|| echo "Working on $sytxts (local system) ..."

	count_all=$count_all+1

	# Check target directory
	if [ -z "$target" ]; then
		echo "No target directory specified for \"$system\"!? Skipped!"
		echo; continue
	fi
	if [ ! -d "$target" ]; then
		echo "Target \"$target\" is not a directory!? \"$system\" skipped!"
		echo; continue
	fi

	sys_target="$target/$fname"
	if [ "$DRYRUN" -eq 0 ]; then
		mkdir -p "$sys_target" >/dev/null 2>&1
		if [ $? -ne 0 ]; then
			echo "Can't create \"$sys_target\"!? \"$system\" skipped!"
			echo continue
		fi
	fi

	if [ "$local" -eq 0 -a "$ping" -ne 0 ]; then
		# Check if system is alive
		ping -c 1 "$system" >/dev/null 2>&1
		if [ $? -ne 0 ]; then
			echo "Host \"$system\" seems not to be alive!? Skipped."
			echo; continue
		fi
		echo "OK, host \"$system\" seems to be alive."
	fi

	if [ $generations -gt 0 ]; then
		# Make sure no old backup is stored in system directory
		if [ -e "$sys_target/.stamp" ]; then
			# There seems to be a genearation-less backup in the
			# target directory!
			echo "Target directory \"$sys_target\" seems to be unclean!? \"$system\" skipped!"
			echo; continue
		fi

		# Search directory of last generation, if any
		last="`ls -1 "$sys_target" 2>/dev/null | sort -r | head -n1`"
		if [ -n "$last" ]; then
			last="$sys_target/$last"
			if [ ! -d "$last" ]; then
				echo "Last snapshot \"$last\" seems not to be a directory!? \"$system\" skipped!"
				echo; continue
			fi
		fi
		sys_target="$sys_target/`date +%Y%m%d-%H%M%S`"

		if [ -n "$last" -a ! -e "$last/.stamp" ]; then
			# Old backup directory without "stamp file", continue
			echo "Found incomplete snapshot in \"$last\", reusing and renaming it ..."
			mv "$last" "$sys_target" >/dev/null 2>&1
			if [ $? -ne 0 ]; then
				echo "Failed to rename last snapshot \"$last\" to \"$sys_target\"!? \"$system\" skipped!"
				echo; continue
			fi
		elif [ -n "$last" ]; then
			# Old backup directory found, create new snapshot
			echo "Found last snapshot in \"$last\"."
			if [ "$DRYRUN" -eq 0 ]; then
				btrfs subvolume snapshot \
				  "$last" "$sys_target" >/dev/null 2>&1; r=$?
				if [ $r -ne 0 ]; then
					echo "Can't create btrfs snapshot \"$sys_target\" of \"$last\", code $r!? \"$system\" skipped!"
					echo; continue
				fi
				echo "Created new snapshot in \"$sys_target\"."
			else
				echo " *** Trial run, not creating new snapshot in \"$sys_target\"!"
			fi
		else
			# No old backup found, create new subvolume
			if [ "$DRYRUN" -eq 0 ]; then
				btrfs subvolume create \
				  "$sys_target" >/dev/null 2>&1; r=$?
				if [ $r -ne 0 ]; then
					echo "Can't create btrfs subvolume \"$sys_target\", code $r!? \"$system\" skipped!"
					echo; continue
				fi
				echo "Created new subvolume in \"$sys_target\"."
			else
				echo " *** Trial run, not creating new subvolume \"$sys_target\"!"
			fi
		fi
	fi

	ssh_cmd="ssh"
	[ -n "$ssh_args_add" ] && ssh_cmd="$ssh_cmd $ssh_args_add"

	cmd="rsync --archive"
	[ "$compress" -ne 0 ] && cmd="$cmd --compress"
	cmd="$cmd --rsh=\"$ssh_cmd\" --delete --delete-excluded --sparse"
	[ "$VERBOSE" -gt 0 ] && cmd="$cmd --progress"
	cmd="$cmd --exclude=/dev --exclude=/proc --exclude=/sys"
	cmd="$cmd --exclude=/run --exclude=/tmp --exclude=/var/tmp"
	cmd="$cmd --exclude=/media --exclude=/mnt --exclude=/net"
	cmd="$cmd --exclude=/var/cache/apt --exclude=/var/log"
	[ -n "$exclude_args_add" ] && cmd="$cmd $exclude_args_add"
	[ -n "$rsync_args_add" ] && cmd="$cmd $rsync_args_add"

	[ "$local" -eq 0 ] \
		&& cmd="$cmd ${user}@${system}:/ $sys_target/" \
		|| cmd="$cmd / $sys_target/"

	echo "Backing up to \"$sys_target\" ..."
	echo -n "Start date: "; date
	echo "$cmd"
	count_started=$count_started+1
	ok=0
	
	if [ "$DRYRUN" -eq 0 ]; then
		rm -f "$sys_target/.stamp"
		$SHELL -c "$cmd"; ret=$?
		echo "code=$ret" >"$sys_target/.stamp"
	else
		echo " *** Trial run, not executing synchronization command!"
		ret=0
	fi

	if [ $ret -eq 20 ]; then
		echo "Backup of \"$system\" interrupted. Aborting ..."
		CleanUp
		exit 1
	fi

	echo -n "End date: "; date
	if [ $ret -eq 0 -o $ret -eq 24 ]; then
		[ $ret -eq 24 ] && count_ok_vanished=$count_ok_vanished+1

		echo "System \"$system\" completed with status $ret, OK."
		[ "$DRYRUN" -gt 0 ] || count_ok=$count_ok+1
		ok=1
	else
		echo "System \"$system\" completed with ERRORS, code $ret!"
	fi

	# Clean up old generations
	if [ $generations -gt 0 ]; then
		sys_target="$target/$fname"
		to_delete=`ls -1t "$sys_target" 2>/dev/null | tail -n+$generations | sort`
		if [ -n "$to_delete" -a $ok -eq 1 ]; then
			[ "$DRYRUN" -eq 0 ] \
				&& echo "Deleting old backup generations:" \
				|| echo " *** Trial run, not deleting old generations:"
			for delete in $to_delete; do
				dir="$sys_target/$delete"
				if [ ! -e "$dir/.stamp" ]; then
					echo "Not deleting \"$dir\", not a backup directory!?"
					continue
				fi
				last=`stat "$dir/.stamp" 2>/dev/null | grep "^Modify: " \
				 | cut -d':' -f2- | cut -d. -f1`
				echo "Removing backup from" $last "..."
				if [ "$DRYRUN" -eq 0 ]; then
					btrfs subvolume delete \
					 "$dir" >/dev/null 2>&1
					[ $? -eq 0 ] || \
					 echo "Failed to delete \"$dir\"!"
				fi
			done
			echo -n "Clean up finished: "; date
		elif [ -n "$to_delete" ]; then
			echo "There have been errors, not cleaning up old generations!"
		else
			echo "Nothing to clean up."
		fi
	fi

	destinations="$destinations $target"
	echo
done

sync

paths=$( echo $destinations | sed -e 's/ /\n/g' | sort | uniq )
if [ "$DRYRUN" -eq 0 -a -n "$paths" ]; then
	df -h $paths
	echo
fi

CleanUp

echo -n "Done: "; date
echo
[ $count_all -eq 1 ] && s="" || s="s"
echo " - $count_all job$s defined,"
[ $count_started -eq 1 ] && s="" || s="s"
echo " - $count_started job$s started,"
echo " - $count_ok done without errors."
echo

if [ $count_started -ne $count_ok ]; then
	echo "----->  THERE HAVE BEEN ERRORS!  <-----"
	echo
fi

# -eof-
